# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Repository Structure

This is a NestJS multi-tenant API boilerplate. The main codebase is in the `api/` directory.

- `api/` - NestJS backend API with multi-tenant architecture
- `app/` - Reserved for future frontend application (currently empty)

## Working with the API

All development commands should be run from the `api/` directory:

```bash
cd api
```

### Quick Start Commands

```bash
# Install and setup
npm install
npm run docker:up              # Start PostgreSQL
npm run typeorm:migration:run  # Apply migrations

# Development
npm run start:dev              # Start with hot-reload
npm run start:debug            # Start with debugger

# Database migrations
npm run typeorm:migration:generate --name <Name>
npm run typeorm:migration:run
npm run typeorm:migration:revert

# Code quality
npm run lint                   # ESLint with auto-fix
npm run format                 # Prettier formatting
```

## Architecture Overview

### Multi-Tenant System

The API implements complete tenant isolation:

- **JWT Payload**: Every JWT contains `{ sub: userId, tenantId: tenantId }`
- **Tenant Context**: `TenantFilterInterceptor` extracts `tenantId` from JWT and attaches it to requests
- **Access Control**: `TenantRoleGuard` validates user roles (OWNER/ADMIN/MEMBER) per tenant
- **Data Filtering**: All repository queries automatically filter by tenant ID

**Adding tenant-scoped resources:**
1. Add `tenantId` column to entity with `@ManyToOne` relation to `Tenant`
2. Always filter repository queries by the active tenant ID
3. Protect routes with `@UseGuards(JwtAuthGuard, TenantRoleGuard)` and `@Roles()` decorators

### Authentication Flow

- **Keycloak-only authentication** - Users authenticate via Keycloak SSO
- User records synchronized from Keycloak JWT tokens to local database
- Refresh tokens stored in `refresh_tokens` table (for API sessions)
- JWT strategy validates Keycloak tokens and syncs user data
- Auto-tenant creation for new Keycloak users (if no tenant specified in token)
- No password storage - authentication fully delegated to Keycloak

### External Integrations

Located in `api/src/common/integrations/`:

- **mail/** - Mailjet integration for transactional emails
- **yousign/** - eIDAS-compliant electronic signatures
- **ar24/** - Registered mail service

Each integration is a standalone NestJS module with service, exceptions, and interfaces.

### Module Structure

Each feature module follows this pattern:

```
module-name/
├── controllers/  → HTTP layer (routes, validation)
├── services/     → Business logic
├── repositories/ → Data access (TypeORM)
├── entities/     → Domain models
├── dto/          → Request/response validation
└── exceptions/   → Domain-specific errors
```

**Layer responsibilities:**
- Controllers handle HTTP concerns and delegate to services
- Services contain business logic and coordinate repositories
- Repositories encapsulate TypeORM queries and data access
- Keep these layers separated for maintainability

## Key Implementation Patterns

### Role-Based Access Control

Roles are defined in `TenantRole` enum:
- `OWNER` - Full control, cannot be removed from tenant
- `ADMIN` - Can manage members and invitations
- `MEMBER` - Can access tenant data

Protect endpoints:
```typescript
@UseGuards(JwtAuthGuard, TenantRoleGuard)
@Roles(TenantRole.OWNER, TenantRole.ADMIN)
```

### Tenant Isolation in Queries

Always filter by tenant ID in repository methods:

```typescript
findByTenant(tenantId: string, options?: FindOptions) {
  return this.repository.find({
    where: { tenant: { id: tenantId }, ...options?.where },
    ...options
  });
}
```

### Invitation System

- Invitations managed in `tenants` module
- Stored in `invitations` table with expiry timestamps
- Email templates use Handlebars via `MailTemplateService`
- Acceptance creates minimal user record (email only) - full profile populated on first Keycloak login
- Links user to tenant via `TenantUser` with specified role

### User Data Management

**User Entity Structure**:
- `id` (UUID) - Internal primary key generated by Postgres
- `keycloakId` (UUID, nullable, unique) - External reference to Keycloak user
- `email` (unique) - Synchronized from Keycloak
- `firstName`, `lastName` (nullable) - User-managed profile data (local priority)
- **No password field** - Authentication delegated to Keycloak

**Data Synchronization**:
- Email always synchronized from Keycloak (source of truth for identity)
- firstName/lastName only synced if empty locally (user can modify in app)
- keycloakId populated on first login via Keycloak
- Internal ID used for all database relations (stable across identity provider changes)

## Development Workflow

1. **Adding features**: Create module with full layered structure (controller → service → repository)
2. **Database changes**: Generate TypeORM migration with `npm run typeorm:migration:generate`
3. **Testing endpoints**: Swagger UI available at http://localhost:3000/swagger
4. **Pre-commit**: Husky runs ESLint and Prettier via lint-staged

## Configuration

Environment variables configured in `api/.env` (see `api/.env.example`):

- Database connection (PostgreSQL)
- JWT secrets and expiration
- External service API keys (Mailjet, Yousign, AR24)
- Sentry DSN for error tracking
- Rate limiting thresholds
